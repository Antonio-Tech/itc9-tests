/*
 * ESPRESSIF MIT License
 *
 * Copyright (c) 2021 <ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD>
 *
 * Permission is hereby granted for use on all ESPRESSIF SYSTEMS products, in which case,
 * it is free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "board.h"
#include "esp_err.h"
#include "esp_log.h"
#include "esp_timer.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "lv_port.h"
#include "lvgl.h"
#include "tt21100.h"
// WIFI/BT FIX: Add WiFi event monitoring includes
#include "esp_event.h"
#include "esp_wifi.h"

#ifndef LCD_H_RES
#define LCD_H_RES 240
#endif

#ifndef LCD_V_RES
#define LCD_V_RES 240
#endif

typedef enum {
    TP_VENDOR_NONE = -1,
    TP_VENDOR_TT = 0,
    TP_VENDOR_FT,
    TP_VENDOR_MAX,
} tp_vendor_t;

static lv_disp_drv_t disp_drv;
static const char *TAG = "lv_port";
static esp_lcd_panel_handle_t panel_handle;

static void *p_user_data = NULL;
static bool (*p_on_trans_done_cb)(void *) = NULL;
static SemaphoreHandle_t lcd_flush_done_sem = NULL;
bool lcd_trans_done_cb(esp_lcd_panel_io_handle_t, esp_lcd_panel_io_event_data_t *, void *);
static tp_vendor_t tp_vendor = TP_VENDOR_TT;

// WIFI/BT FIX: WiFi-aware display management
static int consecutive_failures = 0;
static const int MAX_CONSECUTIVE_FAILURES = 3;  // Reduced threshold
static bool display_recovery_in_progress = false;
static bool wifi_activity_detected = false;
static TickType_t last_wifi_activity_time = 0;
static SemaphoreHandle_t spi_resource_mutex = NULL;
static bool lvgl_paused = false;
static lv_disp_t* display_instance = NULL;

// Forward declarations
static esp_err_t recover_display_communication(void);
static bool is_wifi_activity_high(void);
static esp_err_t wait_for_spi_availability(void);

// WIFI/BT FIX: Display recovery function to restore communication after SPI failures
static esp_err_t recover_display_communication(void)
{
    if (display_recovery_in_progress) {
        ESP_LOGW(TAG, "Display recovery already in progress, skipping");
        return ESP_ERR_INVALID_STATE;
    }
    
    display_recovery_in_progress = true;
    ESP_LOGW(TAG, "Starting display recovery procedure...");
    
    // Step 1: Reset the display panel
    esp_err_t ret = esp_lcd_panel_reset(panel_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to reset display panel: %s", esp_err_to_name(ret));
    } else {
        ESP_LOGI(TAG, "Display panel reset successful");
    }
    
    // Step 2: Allow some time for the display to stabilize
    vTaskDelay(pdMS_TO_TICKS(50));
    
    // Step 3: Reinitialize the display
    ret = esp_lcd_panel_init(panel_handle);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to reinitialize display panel: %s", esp_err_to_name(ret));
    } else {
        ESP_LOGI(TAG, "Display panel reinitialized successfully");
    }
    
    // Step 4: Turn on the display
    ret = esp_lcd_panel_disp_on_off(panel_handle, true);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to turn on display: %s", esp_err_to_name(ret));
    } else {
        ESP_LOGI(TAG, "Display turned on successfully");
    }
    
    // Step 5: Reset failure counter on successful recovery
    consecutive_failures = 0;
    display_recovery_in_progress = false;
    
    ESP_LOGW(TAG, "Display recovery procedure completed");
    return ESP_OK;
}

static void lv_tick_inc_cb(void *data)
{
    uint32_t tick_inc_period_ms = *((uint32_t *) data);
    lv_tick_inc(tick_inc_period_ms);
}

static bool lv_port_flush_ready(void *arg)
{
    /* Inform the graphics library that you are ready with the flushing */
    lv_disp_flush_ready(&disp_drv);
    /* portYIELD_FROM_ISR (true) or not (false). */
    return false;
}

static esp_err_t touch_ic_read(uint8_t *tp_num, uint16_t *x, uint16_t *y, uint8_t *btn_val)
{
    esp_err_t ret_val = ESP_OK;
    uint16_t btn_signal = 0;

    switch (tp_vendor) {
//        case TP_VENDOR_TT:
//            ret_val |= tt21100_tp_read();
//            ret_val |= tt21100_get_touch_point(tp_num, x, y);
//            ret_val |= tt21100_get_btn_val(btn_val, &btn_signal);
//            break;
        case TP_VENDOR_FT:
            break;
        default:
            return ESP_ERR_NOT_FOUND;
            break;
    }

#if TOUCH_PANEL_SWAP_XY
    uint16_t swap = *x;
    *x = *y;
    *y = swap;
#endif

#if TOUCH_PANEL_INVERSE_X
    *x = LCD_H_RES - ( *x + 1);
#endif

#if TOUCH_PANEL_INVERSE_Y
    *y = LCD_V_RES - (*y + 1);
#endif

    ESP_LOGV(TAG, "[%3u, %3u]", *x, *y);
    return ret_val;
}

static void button_read(lv_indev_drv_t *indev_drv, lv_indev_data_t *data)
{
    static uint8_t prev_btn_id = 0;
    uint8_t tp_num = 0, btn_val = 0;
    uint16_t x = 0, y = 0;
    /* Read touch point(s) via touch IC */
    if (ESP_OK != touch_ic_read(&tp_num, &x, &y, &btn_val)) {
        return;
    }

    /*Get the pressed button's ID*/
    if (btn_val) {
        data->btn_id = btn_val;
        data->state = LV_INDEV_STATE_PRESSED;
    } else {
        data->btn_id = 0;
        data->state = LV_INDEV_STATE_RELEASED;
    }

    if (prev_btn_id != data->btn_id) {
        lv_event_send(lv_scr_act(), LV_EVENT_HIT_TEST, (void *) (int)btn_val);
    }

    prev_btn_id = btn_val;
}

static IRAM_ATTR void touchpad_read(lv_indev_drv_t *indev_drv, lv_indev_data_t *data)
{
    uint8_t tp_num = 0, btn_val = 0;
    uint16_t x = 0, y = 0;
    /* Read touch point(s) via touch IC */
    if (ESP_OK != touch_ic_read(&tp_num, &x, &y, &btn_val)) {
        return;
    }

    ESP_LOGV(TAG, "Touch (%u) : [%3u, %3u]", tp_num, x, y);

    /* FT series touch IC might return 0xff before first touch. */
    if ((0 == tp_num) || (5 < tp_num)) {
        data->state = LV_INDEV_STATE_REL;
    } else {
        data->point.x = x;
        data->point.y = y;
        data->state = LV_INDEV_STATE_PR;
    }
}

// WIFI/BT FIX: WiFi activity detection functions
static bool is_wifi_activity_high(void) {
    // Only consider WiFi activity high during critical operations
    TickType_t current_time = xTaskGetTickCount();
    TickType_t time_since_last_activity = current_time - last_wifi_activity_time;
    
    // Much shorter window - only 100ms for critical operations
    return (time_since_last_activity < pdMS_TO_TICKS(100)) && wifi_activity_detected;
}

static esp_err_t wait_for_spi_availability(void) {
    // If WiFi activity is high, wait a bit for it to calm down
    if (is_wifi_activity_high()) {
        ESP_LOGD(TAG, "High WiFi activity detected, waiting for SPI availability...");
        
        // Wait up to 50ms for WiFi activity to decrease
        for (int i = 0; i < 10; i++) {
            vTaskDelay(pdMS_TO_TICKS(5));
            if (!is_wifi_activity_high()) {
                ESP_LOGD(TAG, "WiFi activity decreased, proceeding with display update");
                break;
            }
        }
    }
    return ESP_OK;
}

static void disp_flush(lv_disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p)
{
    (void) disp_drv;
    
    // AGGRESSIVE FIX: If we're experiencing many consecutive failures, 
    // pause all display updates until WiFi activity settles
    if (consecutive_failures >= MAX_CONSECUTIVE_FAILURES) {
        ESP_LOGW(TAG, "Critical SPI failure state - skipping display update until recovery");
        
        // Wait for WiFi activity to settle
        if (is_wifi_activity_high()) {
            ESP_LOGW(TAG, "Waiting for WiFi activity to settle before attempting display recovery...");
            
            // Wait up to 500ms for WiFi to settle
            int wifi_wait_count = 0;
            while (is_wifi_activity_high() && wifi_wait_count < 100) {
                vTaskDelay(pdMS_TO_TICKS(5));
                wifi_wait_count++;
            }
            
            if (wifi_wait_count >= 100) {
                ESP_LOGW(TAG, "WiFi activity did not settle, proceeding anyway");
            } else {
                ESP_LOGI(TAG, "WiFi activity settled after %dms", wifi_wait_count * 5);
            }
        }
        
        // Attempt recovery now that WiFi has settled
        if (!display_recovery_in_progress) {
            ESP_LOGW(TAG, "Attempting display recovery after WiFi settled");
            esp_err_t recovery_ret = recover_display_communication();
            if (recovery_ret == ESP_OK) {
                ESP_LOGI(TAG, "Display recovery successful");
                consecutive_failures = 0;
            } else {
                ESP_LOGE(TAG, "Display recovery failed: %s", esp_err_to_name(recovery_ret));
            }
        }
        
        // Always complete the flush to prevent LVGL hanging
        lv_disp_flush_ready(disp_drv);
        return;
    }
    
    /* WIFI FIX: Wait for previous transmission done with timeout to prevent deadlock */
    const TickType_t timeout_ticks = pdMS_TO_TICKS(50);  // Reduced timeout
    if (pdPASS != xSemaphoreTake(lcd_flush_done_sem, timeout_ticks)) {
        ESP_LOGW(TAG, "LCD flush semaphore timeout - WiFi conflict detected, skipping update");
        lv_disp_flush_ready(disp_drv);
        consecutive_failures++;
        return;
    }
    
    // AGGRESSIVE FIX: Skip display updates during high WiFi activity
    if (is_wifi_activity_high()) {
        ESP_LOGW(TAG, "High WiFi activity detected - skipping display update");
        if (likely(NULL != lcd_flush_done_sem)) {
            xSemaphoreGive(lcd_flush_done_sem);
        }
        lv_disp_flush_ready(disp_drv);
        return;
    }
    
    ESP_LOGD(TAG, "Display update: %dx%d", area->x2 + 1 - area->x1, area->y2 + 1 - area->y1);
    
    // Try the SPI transaction with minimal retries
    esp_err_t ret = esp_lcd_panel_draw_bitmap(panel_handle, area->x1, area->y1, 
                                              area->x2 + 1, area->y2 + 1, (uint8_t *) color_p);
    
    if (ret != ESP_OK) {
        consecutive_failures++;
        ESP_LOGW(TAG, "Display transaction failed: %s (consecutive failures: %d)", 
                 esp_err_to_name(ret), consecutive_failures);
    } else {
        // Reset consecutive failures on successful transaction
        if (consecutive_failures > 0) {
            ESP_LOGI(TAG, "Display communication recovered, resetting failure counter");
            consecutive_failures = 0;
        }
    }
    
    // Always release semaphore and complete flush
    if (likely(NULL != lcd_flush_done_sem)) {
        xSemaphoreGive(lcd_flush_done_sem);
    }
    
    lv_disp_flush_ready(disp_drv);
}

#define USING_STATIC_DISP_BUF 0
static void lv_port_disp_init(void)
{
    static lv_disp_draw_buf_t draw_buf_dsc;

    /* Option 2 : Using static space for display buffer */
 #if  USING_STATIC_DISP_BUF
    size_t disp_buf_height = 40;
    static lv_color_t p_disp_buf[LCD_H_RES * 40];
#else
    // WIFI FIX: Use double buffering with optimized buffer size
    // Larger buffers reduce the number of SPI transactions needed
    size_t disp_buf_height = 80;  // Increased from 60 to 80 for better performance
    static lv_color_t * p_disp_buf1 = NULL;
    static lv_color_t * p_disp_buf2 = NULL;
    
    // WIFI FIX: Allocate primary buffer in PSRAM for better performance
    p_disp_buf1 = heap_caps_malloc(LCD_H_RES * disp_buf_height * sizeof(lv_color_t), MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
    if (!p_disp_buf1) {
        ESP_LOGW(TAG, "Failed to allocate primary display buffer in PSRAM, trying internal RAM");
        p_disp_buf1 = heap_caps_malloc(LCD_H_RES * disp_buf_height * sizeof(lv_color_t), MALLOC_CAP_8BIT);
    }
    
    // WIFI FIX: Allocate secondary buffer for double buffering
    // This allows one buffer to be updated while the other is being transmitted
    p_disp_buf2 = heap_caps_malloc(LCD_H_RES * disp_buf_height * sizeof(lv_color_t), MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
    if (!p_disp_buf2) {
        ESP_LOGW(TAG, "Failed to allocate secondary display buffer in PSRAM, using single buffer");
        p_disp_buf2 = NULL;  // Fall back to single buffer mode
    }
    
    ESP_LOGI(TAG, "Display buffers allocated: primary=%p, secondary=%p, size=%u bytes each",
             p_disp_buf1, p_disp_buf2, (unsigned int)(LCD_H_RES * disp_buf_height * sizeof(lv_color_t)));
#endif

    /* Initialize display buffer with double buffering if available */
    lv_disp_draw_buf_init(&draw_buf_dsc, p_disp_buf1, p_disp_buf2, LCD_H_RES * disp_buf_height);

    /* Register the display in LVGL */
    lv_disp_drv_init(&disp_drv);

    /*Set the resolution of the display*/
    disp_drv.hor_res = LCD_H_RES;
    disp_drv.ver_res = LCD_V_RES;

    /* Used to copy the buffer's content to the display */
    disp_drv.flush_cb = disp_flush;

    /*Set a display buffer*/
    disp_drv.draw_buf = &draw_buf_dsc;

    /* Use lcd_trans_done_cb to inform the graphics library that flush already done */
    p_on_trans_done_cb = lv_port_flush_ready;
    p_user_data = NULL;

    /*Finally register the driver*/
    lv_disp_drv_register(&disp_drv);
}

static void lv_port_indev_init(void)
{
    static lv_indev_drv_t indev_drv_tp;
    static lv_indev_drv_t indev_drv_btn;

    /* Register a touchpad input device */
//    lv_indev_drv_init(&indev_drv_tp);
//    indev_drv_tp.type = LV_INDEV_TYPE_POINTER;
//    indev_drv_tp.read_cb = touchpad_read;
//    lv_indev_drv_register(&indev_drv_tp);

    lv_indev_drv_init(&indev_drv_btn);
    indev_drv_btn.type = LV_INDEV_TYPE_BUTTON;
    indev_drv_btn.read_cb = button_read;
    lv_indev_drv_register(&indev_drv_btn);
}

static esp_err_t lv_port_tick_init(void)
{
    static const uint32_t tick_inc_period_ms = 5;
    const esp_timer_create_args_t periodic_timer_args = {
        .callback = lv_tick_inc_cb,
        .name = "",     /* name is optional, but may help identify the timer when debugging */
        .arg = (void *) &tick_inc_period_ms,
        .dispatch_method = ESP_TIMER_TASK,
        .skip_unhandled_events = true,
    };

    esp_timer_handle_t periodic_timer;
    ESP_ERROR_CHECK(esp_timer_create(&periodic_timer_args, &periodic_timer));

    /* The timer has been created but is not running yet. Start the timer now */
    ESP_ERROR_CHECK(esp_timer_start_periodic(periodic_timer, tick_inc_period_ms * 1000));
    return ESP_OK;
}

bool lcd_trans_done_cb(esp_lcd_panel_io_handle_t panel_io, esp_lcd_panel_io_event_data_t *user_data, void *event_data)
{
    (void) panel_io;
    (void) user_data;
    (void) event_data;
    /* Used for `bsp_lcd_flush_wait` */
    if (likely(NULL != lcd_flush_done_sem)) {
        xSemaphoreGive(lcd_flush_done_sem);
    }
    if (p_on_trans_done_cb) {
        return p_on_trans_done_cb(p_user_data);
    }

    return false;
}

// WIFI/BT FIX: WiFi event handler to detect wireless activity
static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data)
{
    // Only mark activity for events that might cause heavy SPI conflicts
    switch (event_id) {
        case WIFI_EVENT_STA_START:
        case WIFI_EVENT_STA_STOP:
        case WIFI_EVENT_STA_CONNECTED:
        case WIFI_EVENT_STA_DISCONNECTED:
            // These events might cause temporary heavy activity
            wifi_activity_detected = true;
            last_wifi_activity_time = xTaskGetTickCount();
            ESP_LOGD(TAG, "Critical WiFi event detected: %d - marking high activity period", event_id);
            break;
        default:
            // Other events are less critical, don't block display
            ESP_LOGV(TAG, "Non-critical WiFi activity event: %d", event_id);
            break;
    }
}

// WIFI/BT FIX: IP event handler to detect network activity
static void ip_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data)
{
    // Mark network activity
    wifi_activity_detected = true;
    last_wifi_activity_time = xTaskGetTickCount();
    
    ESP_LOGD(TAG, "IP event detected: %d - marking high activity period", event_id);
}

esp_err_t lv_port_init(void *lcd_panel_handle)
{
    panel_handle  = lcd_panel_handle;
    lcd_flush_done_sem = xSemaphoreCreateBinary();

    xSemaphoreGive(lcd_flush_done_sem);
    
    // WIFI/BT FIX: Initialize SPI resource mutex
    spi_resource_mutex = xSemaphoreCreateMutex();
    if (spi_resource_mutex == NULL) {
        ESP_LOGE(TAG, "Failed to create SPI resource mutex");
        return ESP_ERR_NO_MEM;
    }
    
    // WIFI/BT FIX: Register WiFi event handlers to detect wireless activity
    ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_event_handler, NULL));
    ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, ESP_EVENT_ANY_ID, &ip_event_handler, NULL));
    
    ESP_LOGI(TAG, "WiFi activity monitoring initialized");

//    tt21100_tp_init();

    /* Initialize LVGL library */
    lv_init();

    /* Register display for LVGL */
    lv_port_disp_init();
    /* Register input device for LVGL*/
    lv_port_indev_init();

    /* Initialize LVGL's tick source */
    lv_port_tick_init();
    /* Nothing error */
    return ESP_OK;
}
